This is a compiler. It takes in ASTs, converts them into LLVM IR, uses LLVM to compile the IR, and then runs the resulting function.
Currently supported basic commands are addition, variables, structs, branching, and pointers. More advanced commands involve creating random ASTs, and then compiling these randomly-generated ASTs during runtime.
There is a type system supporting this language, consisting of integers, pointers, a "concatenate" command for structs, ASTs, and functions.
The language uses a stack, and is mainly C-like in its architecture.


Technical details:
There are two classes in types.h that support attaching compile-time information to enums; they are named AST_info and Type_info. They have a few helper functions to work with this information, such as Typen(), which converts a string to the relevant integer, and can be run at compile time. All of this relies strongly on the C++14 feature constexpr, and this is the reason that Visual Studio stands no chance of compiling my program.
	This enables me to consolidate significant loose information into a single spot, to reduce potential for errors.
There is a type uniquer in unique_type_creator.cpp that takes a copy of a Type, searches for any existing versions of that Type, and then returns a unique version of that Type. To do this, it operates recursively on subtypes. In addition, it uses a special hash table for Types.
	There is a basic unit test for this type uniquer in unique_type_creator.cpp, under the name test_unique_types().
There is a type checker in types.cpp that compares types to each other. It needs to recurse on both types simultaneously, so it has complex control flow by maintaining two stacks and recursing on either stack, as necessary.
There are several debug functions in debug_output.h that allow introspection on various objects. One such function, output_AST_console_version(), allows the user to copy paste failing functions back into the console input, thus allowing for fast debugging.
The main tool I use to manage LLVM's interface is compile_AST(), which handles the dirty stuff like Modules, FunctionPassManagers, MemoryManagers, etc.
The main tool I use to convert ASTs into IR is generate_IR().
The fuzzer is fuzztester() in cs11.cpp. This has been amazingly useful, giving coverage far beyond any set of manual unit tests. The reason I ever know about segfaulting behavior is thanks to the power of fuzztester(); otherwise, I would have found almost none of the segfaults that appear week after week. Implementing a fuzzer was the best decision in the entire program.
The console input is handled by main() in cs11.cpp. It takes in user-constructed ASTs and then compiles them. This has also been excellent for debugging and reducing testcases, as the fuzzer often produces huge testcases with a lot of junk. Having a user-controllable AST generator was an excellent complement to the fuzzer.
The timer is handled by main() as well; it runs the fuzzer a few time and then calculates the overall time.


Errata:
There is a C++ source wrapper that converts code with long lines into code with <100 lines.
Profiling guide in "docs/profiling"