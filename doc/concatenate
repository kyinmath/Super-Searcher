
concatenate() was formerly necessary for passing in values to functions, but we don't have function parameters anymore.
concatenate(), or something like it, is necessary for passing in values to create_AST().
	although in this case, a vector would be more useful.
are static concatenations any good? you may want to dynamically concatenate multiple objects. however, you can just do dynamic concatenation and the admin will optimize it out.
compilation() returns errors, but that is also dynamic.
	no, it's not. it returns both an error code and a dynamic object.
	well, we can bake the error code into the dynamic object. but that will require us to add a special failure case "in case" the error code fails.
	we could also remove the error code entirely.
other than that, no ASTs return concatenations.
for the user, some objects usually belong together. like nodes in a tree. for recursive types, we can rely on dynamic pointers. but what about other types?
	concatenations are useless locally. it's only when you put them in the heap, and pass them to functions, that they matter.
	so: when should we pass a concatenation from function to function, such that the object is not recursive?
however, it doesn't make sense if we force things to become dynamic before concatenating them. that requires a lot of steps: making pointers to them (hard), changing the pointer to dynamic (hard), and then finally concatenating them.
