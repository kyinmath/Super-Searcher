1. privileged things (dynarray)
	1.1 higher judgment functions. the higher judgment function is a quine, and occasionally makes copies of itself. contains many copies of the same command, so that randomness doesn't suddenly run out (we don't want our user to become a Turing machine)
		on new-user event, it runs on the directed judgment function.
		on new-country event, it runs on itself.
	1.2 directed judgment functions. how do we store information on each of these? every time we copy it, we ought to copy some comments...

1. big set of things (dynarray)
	1.1 working functions
	1.2 goodness indicators (mostly integers)
	1.4, 1.5... mostly integers. sometimes commented integers.
to store comments on things, we use dynamic pointers. the dynamic pointer to the big array stores more dynarrays, which contain the object of interest in the first slot. we don't point to the object directly.

1. we have a directed-judgment function. it randomly gets functions from the big tree of things and then modifies them. it should have some purpose. 
to do this, it picks a function, looks for static-object ASTs, and changes them. but it remembers the old values.
	then it runs the simulation, assigns goodness, and decides to revert or not.
	it creates random functions, and inserts calls to them (fuzztester)
	
but then, it also looks for random functions, copies AST. then it snips out part of them.
	then it goes to another function, and then tries inserting the new segment inside. maybe making a few tweaks.
	there is a huge mess of global integers that are randomly modified. basically, neurotransmitter levels. there are some functions which store constant values into them, some functions which grab some levels and then randomly store into other levels.
		we will rely on this for 
	loops should be able to modify their condition somehow, and are under great suspicion.
how can it find ASTs? that's because all the ASTs must be stored in a vector.
	they should all be versioned, as well. with some level of "goodness". when you fail to make a change, the "stability" value goes up. high stability = low rate of changing.
2. we have a goodness function. somehow, it produces an evaluation of how well you did, and encodes them in some global variables somewhere.
	then, the directed-judgment function uses these special goodness values to do something.
3. random-judgment function.
	randomly changes the goodness function and the directed-judgment function, and itself. also gets values from goodness, to randomly decide its behavior.
	it also makes copies of the directed-judgment function, occasionally kills them.
	these functions ought to be run in parallel.
4. culling function. we don't want memory to explode. so this takes especially useless functions and throws them away.
how do we decide which functions should be called?
	there should be some "reset" functions, that happen when something really bad happens. after a long string of badness, these functions are called.
problem: we can't take in negative feedback, only positive feedback. this is because our changes don't have true negatives, since they're random and arbitrary.

things that are important are repeated many times. just like in DNA.

Function recombination: modification of existing functions. each step is repeated as many times as necessary.
	after each change, we should generally test if the function will still compile. if it won't compile, we must roll-back. roll-back is necessarily baked into the function.
1. browsing mode
	1. choose a random function to obtain from
	2. snip the function by choosing a head, then copying
2. insertion mode
	1. in some other function, find some location by randomly browsing.
	2. find a snipping location by going down previous_BB pointers, and choosing two points.
		insert the head in the top of the snip.
		browse through the snippet's backpointers to find the bottom. change the bottom's AST to point to the original snip.
3. random modification. insertion adds in code, but now we have to mix the code to make it interact.
	1. randomly browse the function, memorizing AST locations.
	2. randomly change some AST locations to other ASTs.

Revolution and kingship. necessary, because judgment can't repair itself.
eventually, we'll want some kind of sexual reproduction. well, that's hard.
	it's easy if users can communicate by sending big objects to each other. (in this case, the important thing is to know the total size of the object)


copy ASTs. replace some chains of ASTs with chains of other ASTs.
memorize a part of an AST, then insert it into another function (DNA splicing)

how do we schedule judgment to run, so that one judgment function can't just run away with everything?