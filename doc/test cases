[concatenate [imv 1] [imv 2]] [imv 3]
	still causes extra cast
[concatenate [imv 1] [imv 2]]
	causes a ridiculous amount of GEPs
	in the case of concatenate, stack_degree 2, there's no point in RVO into an existing slot. because you have to load it out from the slot anyway, one at a time.


[concatenate [concatenate [integer] [integer]] [integer]]
[concatenate [integer] [concatenate [integer] [integer]]]
	why isn't this working? middle is not 0
[concatenate [concatenate [concatenate [integer] [integer]] [integer]] [integer]]
	this works.


[convert_to_AST [random] [scope] [dynamic]]
	usually ought to fail. random > highest possible tag
[convert_to_AST [integer 7] [scope] [dynamic]]
	should produce a [random] AST






[dynamify]dyn [dyn_subobj dyn [imv 2]]
[dynamify]dyn [dyn_subobj dyn [imv 0]]
//for single size object. 0 and above
[imv 0]ret [imv 40]a [dynamify [pointer a]]dyn [dyn_subobj dyn [imv 0] [store [pointer ret] [copy subobj]] [[store [pointer ret] [copy subobj]]]]subobj
[imv 0]ret [imv 40]a [dynamify [pointer a]]dyn [dyn_subobj dyn [imv 0] [load_object
//for concatenate object. 0 and above.
[concatenate [imv 40]in [pointer in]]a [dynamify [pointer a]]dyn [dyn_subobj dyn [imv 0] 
[concatenate [imv 40]in [pointer in]]a [dynamify [pointer a]]dyn [dyn_subobj dyn [imv 1] 

//tests moving objects to higher lifetimes. a pointer to in gets stored to p, so the concatenation better stay alive.
[imv 30]dummy [pointer dummy]p [concatenate [imv 40]in [store [pointer p] [pointer in]]]a [increment [copy p]]
	error? too many fields?


[imv 30]dummy [pointer dummy]p [concatenate [imv 40]in [store [pointer p] [pointer in]]]