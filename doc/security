Usually, Xeon-series processors have much larger L3 cache and higher multi-core capacity (up to 12) than comparable i-series processors on top of other server/workstation nitty-gritty details and optimizations for server-specific tasks.
The other benefit of 2011 is more channels for RAM. 8x isn't uncommon and some configurations even use tri-channel memory.
Additionally, Socket 2011 + Xeon allows for ECC RAM, which is very desirable for server and workstation environments. I would even go so far as to say this is the #2 reason people get 2011+Xeon, and sometimes even the #1 reason.
Oh, and multi-socket motherboards, sure. If that's your thing.
So... TL;DR: More cores, more cache, different nitty-gritty features, more RAM channels, ECC RAM, more PCI-E lanes.


on Amazon:
use O3 to obfuscate.
preferably, obfuscate using something else as well.
	upx is not an obfuscator. it just compresses. it'll unpack everything into memory anyway; that's useless
never upload source code.
objdump --full-contents --section=.comment toy
readelf -s toy
	strip -R .comment -R .note -R .note.ABI-tag toy
	strip -s toy
	http://www.thegeekstuff.com/2012/09/strip-command-examples/
	https://reverseengineering.stackexchange.com/questions/47/can-i-create-an-object-file-using-gcc-that-cannot-be-reverse-engineered
note that Ctrl+F through the executable finds a lot of text. try searching for "MCContext". there's zero way to avoid being seen as llvm JIT.
	especially, search for things like "dyn_subobj", "con_vec"


remember, Intel has a VNC server. since everything is already there, it would be trivial for them to backdoor their CPUs?
they can do microcode updates on CPUs in the wild...
	maybe a reason not to give bots admin control; they'd take over the computer for all future users as well.
	or any control really. sandbox completely, because some control = admin control. Windows is as leaky as a sponge.
but linux is vulnerable too. and clang, and any of the services used. intel probably is a small concern.
	moreover, they're vulnerable even non maliciously.

problem: if the user doesn't have admin, someone from outside can come in and compromise things. then it's root vs non root.

warning: virtual machines may prevent AES-NI from working. thus giving non-constant time AES, which can be broken in 80 rounds.

idea: fuzzing to obfuscate. suppose I only want my code to run on a specific, valid input.
	then I can fuzz stupid calls until one of them gives me the behavior I want, like xoring system information with some arbitrary huge bits.
	the other calls should all give sort-of viable information.
	the goal is to mask the initial input - you're feeding it into something that returns basically garbage. but in that sense, it's like a hash function...
		better if you can access random memory this way. so you could potentially call any function. but then the adversary can trace the execution of your function.