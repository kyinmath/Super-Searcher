
_temp_function_vector[nvec [compile]]
[vector_push temp_function_vector [compile]]
_iterations[imv 100]
_main_loop[label]
	_int_function_choice[random]
	_function[load_subobj_ref temp_function_vector [urem int_function_choice [vector_size temp_function_vector]]
	[	_AST_sequence[nvec [pointer [convert_to_AST [zero]]]]
		_offset_sequence[nvec [zero]]
		_base_AST[[pointer load_subobj function [zero]]]
		_current_AST[basicblock base_AST]
		_find_deeper_AST[label]
		[if [current_AST]
			{	_BB_try[load_vector_from_BB current_AST
					{
					[if [lessu [random] 9223372036854775807]
					_time_to_append{}]
					_chosen_offset[urem [random] [vector_size BB_try]]
					_AST_try[load_subobj_ref BB_try chosen_offset
						[if AST_try
						_success{[vector_push AST_sequence current_AST] [vector_push offset_sequence chosen_offset] [store _current_AST AST_try]
						[if [lessu [random] 9223372036854775807] [goto find_deeper_AST]
						_time_to_do_work{[zero]}]}]]}]
				_imv_try[load_imv_from_AST current_AST
					{_dynamic_contain[dyn_subobj imv_try [zero] [label] [store imv_try [multiply [ushr imv_try [imv 32]] [ushr random [imv 31]]]]]}]
				_chosen_offset[urem [random] [system2 [zero] [load_tag current_AST]]]
				_AST_try[load_subobj_ref current_AST chosen_offset
					[if AST_try
					{[vector_push AST_sequence current_AST] [vector_push offset_sequence chosen_offset] [store _current_AST AST_try]
					[if [lessu [random] 9223372036854775807] [goto find_deeper_AST]
					_time_to_do_work{}]}
				]]
			}
		]
	
	_compilation_attempt[compile base_AST]
	[if compilation_attempt [overfunc function compilation_attempt]]
	]
	]
	[store iterations [decrement [iterations]]]
	[if [iterations] [goto main_loop]]
	
		if (tag == ASTn("basicblock")) //simply concatenate two previous basic blocks.
		{
			function* second_prev_func = event_roots.at(generate_random() % event_roots.size());
			uAST** sec_previous_possible = find_random_AST(second_prev_func);
			test_AST = new_AST(tag, {previous_possible ? *previous_possible : 0, sec_previous_possible ? *sec_previous_possible : 0});
		}
		else
		{
			uAST* new_random_AST;
			if (tag == ASTn("imv"))
			{
				//make a random integer
				new_random_AST = new_AST(tag, (uAST*)new_object_value(u::integer.ver(), generate_exponential_dist()));
			}
			else
			{
				std::vector<uAST*> fields;
				for (uint64_t incrementor = 0; incrementor < AST_descriptor[tag].pointer_fields; ++incrementor)
				{
					uAST** previous_possible2 = find_random_AST(previous_func);
					fields.push_back(previous_possible2 ? *previous_possible2 : 0); //get pointers to previous ASTs
				}
				new_random_AST = new_AST(tag, fields);
			}
		}