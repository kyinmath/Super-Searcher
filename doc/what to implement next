variable changing (CreateStore)
	ownership of dynamic objects, so we can overwrite the types.
	type slicing
note that our createstore is not properly atomic, for items like dynamic pointers.
move the fuzzer into AST format

locks?
pointer offsets.
threading, which requires locks

Normally, we'd need locks before we implemented CreateStore.
	but right now, things are ok since all CreateStores are roughly atomic.

createstore probably takes a pointer as its first argument, and the object itself as its second argument.

if we have a dynamic pointer, how do we extract information from it?


we need storage when:
1. we concatenate (?)
	no, in this case we can have a big jumble of values. shove them together only when used.
2. we do do_after, because it might be changed
3. we put something on the stack, because it might be changed, and temps can't change



suppose we have a compiled function. it points to an AST. when the function dies, should we really unimmut the old ASTs? is that at all useful?
	yeah, it's vital. we don't want to create new copies all the time. and we use compilation as error_checking, so we compile a function many times as we create it.

with my store() command, should I be running dtors?

perhaps: we want createstore to be a simply mem copy.
then, dynamic pointers, AST pointers, type pointers: can be double indirection.
	this lets us overwrite multiple-field objects atomically, by creating a whole new copy.
but any old references are going to be left behind forever. for example, if you get a dynamic pointer to the various fields.
	for both ASTs and Types, we can require passthrough using their concatenate() operations.
for dynamic pointers, 