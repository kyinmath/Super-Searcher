variable changing (CreateStore)
	ownership of dynamic objects, so we can overwrite the types.
	type slicing
move the fuzzer into AST format

locks?
pointer offsets.
threading, which requires locks

Normally, we'd need locks before we implemented CreateStore.
	but right now, things are ok since all CreateStores are roughly atomic.

createstore probably takes a pointer as its first argument, and the object itself as its second argument.

if we have a pointer, how do we extract information from it?


I want a console-friendly AST output function, which will require some state tracking so that we don't duplicate ASTs.
But this means that I'll also need to fix up my console input function to support multiple basic blocks.




we want to have goto.
how do labels work?
if there are variables, temps and phis will fail. thus, we first need storage before labels.

RVO must happen using the finish() command. because of do_after. when you call do_after, the existing things must already be put in place. you can't put them in place after returning.

we need storage when:
1. we concatenate (?)
	no, in this case we can have a big jumble of values. shove them together only when used.
2. we do do_after, because it might be changed
3. we put something on the stack, because it might be changed, and temps can't change


we need: passthrough AST, since our dynamic objects can't change types.
does this mean we also need a passthrough Type? but both of these are actually already possible, using concatenate() in Type or AST.

suppose we have a compiled function. it points to an AST. when the function dies, should we really unimmut the old ASTs? is that at all useful?
	yeah, it's vital. we don't want to create new copies all the time. and we use compilation as error_checking, so we compile a function many times as we create it.