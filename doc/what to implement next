1. dynamic_get_type(object)
2. dynamic_assert(object, Type, number)
3. dynamic_assert_pointer
looking at types. we want to get the Nth type. when we get types past the end, we return null (as usual).
move the fuzzer into AST format
	getting types of ASTs
		which requires being able to look at types.
	how to figure out the internals of dynamic objects? since we don't have function parameters, we'll need to use global pointers to pass data.
4. convert dynamic pointer, to dynamic object containing a pointer. this is necessary for static objects.
acquisition of Type and AST values
overwriting ASTs
change GC to handle offset pointers

pointer offsets/type slicing
	should this load the object, or simply return a pointer?
	for ASTs, you might want to store them. so a pointer would work. however, what if we want to change the AST's tag later? but changing tags might not work because you'd have to resize. so pointer-to-AST-pointer is fine. but if we return null, you're fucked, because regular pointers can't be 0.
	for Types, you might as well load. they're immutable anyway.
	for dynamic pointers, if we load, then...you'd need a store_N. and you'd also have to copy the dynamic pointer, in case the dynamic pointer changed in the middle.
		but if we can't get offset pointers, 

if we have a dynamic pointer, how do we extract information from it?
	remember that we can't return a 0 pointer. so it won't be a guaranteed function.
we can do a switch case. however, what will happen if we ever add a type?

suppose we have a compiled function. it points to an AST. when the function dies, should we really unimmut the old ASTs? is that at all useful?
	yeah, it's vital. we don't want to create new copies all the time. and we use compilation as error_checking, so we compile a function many times as we create it.



I think: we have a special "concatenation" type, which is an array. the benefit is the random access: to look at parts of the type, you don't need to repetitively re-get pointers, which would kill finiteness.
	but storing pointers is the same as storing numbers.
	however, having these funny types is bad for constexpr.

maybe: we can use our dynamic types as vector? then we have some kind of speedup for long repetitive types. make sure to consider periodicity as well: ABAB, not just AAAA.
	and what's more, we state that dynamic types don't have to necessarily reallocate. so the old reference may be still relevant, and it may not. user's job to do the appropriate locking.
	the concatenation type being a vector really helps here.
however, what about other full dynamic pointers, that point to the same object? if you're re-writing in place, they no longer point to the entire object, only part of it.
	actually, I think it's ok, since we made it atomic.
	well, dynamic pointers inside ASTs might be in trouble maybe.
	the GC lock ensures multiple things can't be trying to change the type simultaneously.
this system means we can't delete elements from the end of a vector...except we can, vaguely, by truncating the type. then some garbage collection would be necessary, unless the memory region has only a single pointer to it.

we must always consider bootstrap issues. for example, how to make a function that returns compiled functions with fixed type?
	if there's no guaranteed mechanism, then such a function would need a static object to substitute. and it's unlikely the judgment function is able to construct these dynamic objects on the fly.

orcjit: I should run a diff on most recent kaleidoscope version, because lhames is changing orc constantly

is it possible for the second branch of a do-after to look at values from the first branch?
	no, it's not possible. you'd have to go in and edit it afterwards.

try marking check() as constexpr