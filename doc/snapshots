snapshot absolutely should use the existing GC mechanism. otherwise there will be tons of bugs.

snapshotting:
start with a set of base objects. (we have a set of base objects, because we'll use this to copy users as well).
then, run the GC. except each time we find an object using found_living_object, we copy it over to a new allocation.
	then, we keep a map from old locations to new locations.
mark_single(), whenever it finds a pointer, searches the map for the old location, and then changes it to the new location.
	if it fails to find the old location in the map, it errors. this is because mark_single() should recursively mark its targets before it tries to search the map.

note: we have to handle functions in a special way.
and, we must add types to a unique type map whenever we see them. or, if we're snapshotting from a user to himself, we can just avoid copying the types, since they're immutable.


serialization and unserialization:
	grab ASTs from functions. then recompile at time of unserialization.
	reconstruct the Tptr hash table at time of unserialization.
snapshotting:
	copy functions. then recompile.
	don't copy types or do anything with them.
GC:
	no relocations necessary. only need a set, not a map.

the difference is what to do on finding a pointer to:
1. normal object
	GC: put in set.
	snapshot: map, relocate (copy).
	serialize: map, relocate (copy), but as offset from base of memory allocation
2. function
	GC: mark specially.
	snapshot: map, relocate in special place (copy), remember all functions for later recompilation.
	serialize: relocate just the AST in a vector and store the number, recompile every function, recreate the return AST.
3. Tptr
	GC: put in set.
	snapshot: do nothing.
	serialize: map, relocate (copy). on unserialization, put in hash table.