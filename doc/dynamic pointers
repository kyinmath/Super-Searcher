dynamic_conc is pretty inefficient because it makes lots of copies. but for now, we don't care too much

let's say you're browsing through the Big Tree of Stuff, and you get a dynamic pointer. it contains some structure and a function.
	how does the dynamic pointer assert into a static type?


dynamic objects must be able to handle nullptr.
	to support recursive objects
	to support variable numbers of arguments, such as for convert_to_AST.

null types are useful for function return types. and for scope().


we could go back to our old pointer-to-pointer scheme... what benefits would it have?
	1. every single type is single-sized.
	2. dynamic pointers own their targets.







dynamic objects vs dynamic pointers?
	dynamic objects I think, mainly want to be overwritten.
	ASTs actually want dynamic objects, not pointers.
	recursive types want dynamic pointers.
the main issue is that if there are dynamic objects, an object's size can't be inferred from just its type.


dynamic object-in-pointer objects don't fit in our type system. can't store them except at the end of a type. locally, they can just be optimized dynamic pointers.
	but in terms of ownership semantics, dynamic owning pointers can be useful.
	you can have actual vectors, and expand and shrink these vectors.
		but the problem is, you might have references to the insides of the objects when they are moved around.
		so in that case, "deleting" from the back or the front still leaves the valid memory there; it'll still be a valid reference. it'll just be inaccessible.
ASTs basically have dynamic objects, since they own them.


current problem: we don't have a deque.
	what that means is that our fuzztester won't work the way we want it to, since we can't erase from the front.
we're going to have this problem in the future as well. how do we discard elements from a dynamic pointer?
	I think, the problem here is ownership semantics. if we get the target of a dynamic_pointer, we can't get other pointers to the internal of the vector anyway, because of our full stack thing. but we can get other pointers to the vector itself.
on the other hand, if we had dynamic_object, then we'd be able to ensure that there was only ever one handler. then we'd be able to fiddle with the vector's size however we liked, by deleting from either end, expanding, etc.
	but to do this, every time we copied a dynamic object, we'd have to call a copy constructor. no more transparent copies.

can the type of a dynamic object be next to the object, or must it be separated?
	if we want erasure from the front, it must be separated.
	we can't move the pointer along with the base of the object, because we rely on missing memory to keep references valid.
	however, we can specify an offset. so: type, offset, object.
		well, circular buffer might be nice, but the problem is that it becomes hard to reallocate. how do you tell the system that you want an entire reallocation? maybe the system tells you how much memory you have left whenever you add an element. so you can just expand to the end of the memory right away?
what about turning dynamic pointers into pointer-to-dynamic-object?