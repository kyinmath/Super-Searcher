fuzztester is only for error checking. not for actual operation.


[imv 100]iterations
[imv 20]max_fuzztester_size
[dynamify]vector_of_AST_pointers
[label]main_loop
	[dynamify]fuzztester_roots
	[urem [random] [system1 [zero]]]tag
	[system2 [zero] tag]pointer_fields
		uint64_t prev_AST = generate_exponential_dist() % fuzztester_roots.size(); //perhaps: prove that exponential_dist is desired.
		//birthday collisions is the problem. a concatenate with two branches will almost never appear, because it'll result in an active object duplication.
		//but does exponential falloff solve this problem in the way we want?

		std::vector<uAST*> fields;
		uint64_t incrementor = 0;
		for (; incrementor < pointer_fields; ++incrementor)
			fields.push_back(fuzztester_roots.at(mersenne() % fuzztester_roots.size())); //get pointers to previous ASTs
		for (; incrementor < pointer_fields + AST_descriptor[tag].additional_special_fields; ++incrementor)
		{
			if (AST_descriptor[tag].parameter_types[incrementor].type == T::dynamic_pointer)
			{
				fields.push_back((uAST*)(u::integer.ver())); //make a random integer
				fields.push_back((uAST*)new_object(generate_exponential_dist()));
			}
		}
		uAST* test_AST = new_AST(tag, fuzztester_roots.at(prev_AST), fields);
		output_AST_console_version(test_AST);
		fuzztester_roots.pop_back(); //delete the null we put on the back
		finiteness = FINITENESS_LIMIT;
		if (!FUZZTESTER_NO_COMPILE)
		{
			uint64_t result[3];
			compile_returning_legitimate_object(result, (uint64_t)test_AST);
			print("results of user compile are ", result[0], ' ', result[1] , ' ' , result[2] , '\n');
			auto func = (function*)result[0];
			if (result[1] == 0)
			{
				fuzztester_roots.push_back((uAST*)func->the_AST);
				if (fuzztester_roots.size() > max_fuzztester_size)
					fuzztester_roots.pop_front();


				if (DONT_ADD_MODULE_TO_ORC || DELETE_MODULE_IMMEDIATELY)
					continue;

				std::array<uint64_t, 2> dynamic_result = run_null_parameter_function(result[0]);
				uint64_t size_of_return = get_size((Tptr)dynamic_result[0]);
				output_array((uint64_t*)dynamic_result[1], size_of_return);
				//theoretically, this action is disallowed. these ASTs are pointing to already-immuted ASTs, which can't happen. however, it's safe as long as we isolate these ASTs from the user
				++hitcount[tag];
			}
		}
		else
		{
			//don't bother compiling. just shove everything in there.
			fuzztester_roots.push_back(test_AST);
			if (fuzztester_roots.size() > max_fuzztester_size)
				fuzztester_roots.pop_front();
			print(fuzztester_roots.size() - 1, "\n");
			++hitcount[tag];
		}
		//else delete test_AST;
		if (INTERACTIVE)
		{
			print("Press enter to continue\n");
			std::cin.get();
		}
		print("\n");
		if ((generate_random() % (GC_TIGHT ? 1 : 30)) == 0)
			start_GC();
	}
[store iterations [decrement iterations]]
[if iterations [goto main_loop]]
