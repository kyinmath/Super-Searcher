what is the point of full pointers vs cheap pointers? I seem to remember it was for function interfaces.
	but perhaps we can deal with these anyway, without using cheap vs full pointers?
	if a pointer points to another pointer, then...	well, you could always write a full pointer to the interior pointer. and never a cheap pointer to the interior pointer.
	but what about when the function receives the pointer...it doesn't know whether it's a full pointer or not, and thus, it cannot know whether it can copy that pointer into an existing slot.

but moreover, suppose we don't want to care about pointer lifetimes. then everything is automatically on the heap, and then is optimized to the stack when possible.
	the problem is that we can't always optimize things to the stack. because if we pass the pointer to a function, we won't know if the function stores the pointer somewhere.
this is what Java does. https://programmers.stackexchange.com/questions/65281/stack-and-heap-memory-in-java "escape analysis"
	this will mean dtors aren't bound to objects anymore. but they can still see those objects.
cost: if you ever pass a pointer to the object to another function, the parameter is instantly made full. you no longer have the option to do manual memory management.
benefit: no need for make_full(); everything is already full.

since pointers and full pointers are pretty similar, now I am going to put them both in a single type.
0 = cheap, 1 = full, in the second field.
maybe later I'll add in nullable cheap = 2, nullable full = 3.
	this can be done using dynamic types. and since we don't have recursive types anymore, nullable isn't really necessary.
and maybe immut on a bit as well. third bit, 0 = normal, 1 = immut.
	but immut is only good for Types/ASTs. in those cases, we can simply load the object/copy the object. this won't work across function boundaries, but that's fine.
	for functions. if you get a pointer to the actual x86 function, you're fixed. but again, we can have pointer-to-function.


we don't care too much about pointer lifetimes, since normally you can just pass them around as broken-up pointers. since lifetime only matters locally, and is only used for createstore.
	thus, we can afford to lose some power, such as not being able to concatenate.

pointers on the stack can be overwritten with other pointers. this messes with their lifetime values.
when you load a pointer from a memory slot, we know the life guarantee is longer than the pointer itself.
	but we have no idea what the hit contract will be. this is because the pointer can be overwritten
	thus, you can take that pointer and store it somewhere. but you can't store a value into the memory location referenced by that pointer.
and when using createstore (pointer, value), we must have that (guarantee of value) > (hit contract of pointer)
	what is the life guarantee actually good for?
		the "true" lifetime of the pointer itself, which is the lifetime for which the pointer value is valid, is equal to the target guarantee.

what life guarantee is good for is a self validity. when yourself no longer makes sense. so for integers, it's infinity.
	this determines when it's possible to store.

must full pointers point to the beginning of the object?
	+garbage collection is faster, with our bitset. only need to check the first bit to see if you already checked that object.
	+in the future, we'll want mutators to know where the object is, for concurrent GC. will that require knowing the full object?
	-less expressivity. so: what's the cost precisely?
		you can't store the pointer on the heap. when might we want this? for ASTs?
		actually, when might you want big objects on the heap at all? when they logically belong together. for example, one of our big compilation objects (passes).
		in that case, you want to see everything together. then, would there be exceptional cases where you want pointers to just the internals, and to be able to also store these pointers? in those cases, you would be explicitly throwing away information about the overall object.
	and then, what about vectors?
		sure, that seems to work fine with dynamic objects, since the dynamic type can be changed in-place.
		ASTs embed the type inside, but maybe we can just treat them differently.
if so, maybe they'd want to point to the entire object. this is so that after you've checked an object, you know you've handled every field. but this messes with vector truncation