what is the point of full pointers vs cheap pointers? I seem to remember it was for function interfaces.
	but perhaps we can deal with these anyway, without using cheap vs full pointers?
	if a pointer points to another pointer, then...	well, you could always write a full pointer to the interior pointer. and never a cheap pointer to the interior pointer.
	but what about when the function receives the pointer...it doesn't know whether it's a full pointer or not, and thus, it cannot know whether it can copy that pointer into an existing slot.

but moreover, suppose we don't want to care about pointer lifetimes. then everything is automatically on the heap, and then is optimized to the stack when possible.
	the problem is that we can't always optimize things to the stack. because if we pass the pointer to a function, we won't know if the function stores the pointer somewhere.
this is what Java does. https://programmers.stackexchange.com/questions/65281/stack-and-heap-memory-in-java


since pointers and full pointers are pretty similar, now I am going to put them both in a single type.
0 = cheap, 1 = full, in the second field.
maybe later I'll add in nullable cheap = 2, nullable full = 3.
and maybe immut on a bit as well. third bit, 0 = normal, 1 = immut.



we don't care too much about pointer lifetimes, since normally you can just pass them around as broken-up pointers. since lifetime only matters locally, and is only used for createstore.
	thus, we can afford to lose some power, such as not being able to concatenate.

pointers on the stack can be overwritten with other pointers. this messes with their lifetime values.
when you load a pointer from a memory slot, we know the life guarantee is longer than the pointer itself.
	but we have no idea what the hit contract will be. this is because the pointer can be overwritten
	thus, you can take that pointer and store it somewhere. but you can't store a value into the memory location referenced by that pointer.
and when using createstore (pointer, value), we must have that (guarantee of value) > (hit contract of pointer)
	what is the life guarantee actually good for?
		the "true" lifetime of the pointer itself, which is the lifetime for which the pointer value is valid, is equal to the target guarantee.

what life guarantee is good for is a self validity. when yourself no longer makes sense. so for integers, it's infinity.
	this determines when it's possible to store.