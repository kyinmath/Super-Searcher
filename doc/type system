for internal types, we have the option to either represent the type of a stack object as a pointer to the type, or as the actual type. So a uint64_t on the stack may be either ["cheap pointer", ["integer"]] or just ["integer"].
Either way, we'll have to do a transparent conversion from the llvm type when using the "pointer" AST and the "copy" AST, so that the user doesn't need to worry about whether the target AST is on the stack or not. The user does not care about llvm's internal semantics.
Cons of storing the type with a pointer:
	you create an extra pointer. if the type is not used, you've wasted time creating an extra type object.
Cons of storing the actual type:
	every time you use a "pointer" AST, you have to create another pointer type.
Decision: our internal type system doesn't create an extra pointer for stack objects. 
	#our type system represents our conceptual understanding, so that debugging works well.
	#if we ever want a "get type of AST return object" AST, then it will work directly. the return type should not be context dependent on some other ASTs you can't see.